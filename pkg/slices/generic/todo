package generic



	Specification{
		FunctionName: "",
		StandardPath: Behavior{
			Description: "",
			Expectation: func(t *testing.T){
				t.Skip()
			},
		},
		AlternativePath: Behavior{
			Description: "",
			Expectation: func(t *testing.T){
				t.Skip()
			},
		},
	},

/*

AnyS*
AllS*
AutoCorrelate *
CrossCorrelate *
Convolute *
CountSorted *
DistinctSorted *
FilterS *
FirstS *
Flatten *
GroupS *
InsertAfterS *
InsertBeforeS *
IntersectionS *
IsProperSubsetS*
IsProperSupersetS*
IsSubsetS*
IsSupersetS*
LastS*
NoneS*
PartitionS*
RemoveS *
SplitAfterS*  
SplitBeforeS*
SkipUntil *
TakeUntil *

Distinct
Empty
End
Enqueue
Filter
FindIndex
First
Fold
Foldi
ForEach
ForEachConcurrently
Group
Head
Indices
InsertAfter
InsertBefore
InsertAt
Intersection
IsProperSubset
IsProperSuperset
IsSubset
IsSuperset
Item
Iter
Last
Len
Map
None
Pairwise
Partition
Permutable
Permutations
Permute
Pop
Push
Reduce
RemoveAt
Reverse
Skip
SkipWhile
Some
Sort
SplitAfter
SplitAt
SplitBefore
String
Swap
SwapIndex
Tail
Take
TakeWhile
Union
Unzip
WindowedC
WindowedL
WindowedR
Zip

*/


Ripe for performance improvement
Any <- Can do a parallel search, splitting the list into chunks, each scanned by a different channel
Count <- Can be split and counted in parallel
Difference <- currently has a minor optimiation to only scan the shorter list. However, other strategies could improve performance quite a bit.