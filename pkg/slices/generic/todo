package generic



	Specification{
		FunctionName: "",
		StandardPath: Behavior{
			Description: "",
			Expectation: func(t *testing.T){
				t.Skip()
			},
		},
		AlternativePath: Behavior{
			Description: "",
			Expectation: func(t *testing.T){
				t.Skip()
			},
		},
	},

/*

AnyS*
AllS*
AutoCorrelate *
CrossCorrelate *
Convolute *
CountSorted *
DistinctSorted *
FilterS *
FindIndexS *
FindIndices *
FindIndicesS *
FirstS *
Flatten *
ForEachi *
ForEachiC
GroupS *
InsertAfterS *
InsertBeforeS *
IntersectionS *
IsProperSubsetS*
IsProperSupersetS*
IsSubsetS*
IsSupersetS*
LastS*
NoneS*
PartitionS*
RemoveS *
RemoveFirst *
RemoveFirstS *
SplitAfterS*  
SplitBeforeS*
SkipUntil *
TakeUntil *

IsProperSubset
IsProperSuperset
IsSubset
IsSuperset
Item
Iter
Last
Len
Map
None
Pairwise
Partition
Permutable
Permutations
Permute
Pop
Push
Reduce
RemoveAt
Reverse
Skip
SkipWhile
Some
Sort
SplitAfter
SplitAt
SplitBefore
String
Swap
SwapIndex
Tail
Take
TakeWhile
Union
Unzip
WindowedC
WindowedL
WindowedR
Zip

*/


Ripe for performance improvement
Any <- Can do a parallel search, splitting the list into chunks, each scanned by a different channel
Count <- Can be split and counted in parallel
Difference <- currently has a minor optimiation to only scan the shorter list. However, other strategies could improve performance quite a bit.
Group <- internal hashing is really naive. Could be optimized if hashes were sorted.
Intersection <- Currently uses Any() to determine if an element has already been added. This has a low memory overhead, but a huge performance pentalty. A better approach would be to store the matches in a map then convert the map to a slice in a single pass.